# WebSocket Migration Design

## Overview

Migrate the execute API from Server-Sent Events (SSE) to WebSocket for bidirectional communication, better state management, and enhanced features like execution cancellation.

## Current Architecture (SSE)

### Flow
1. Frontend POSTs to `/api/execute-script` with fetch API
2. Backend streams events via SSE: `expressions` → results → `complete`
3. Frontend manually parses SSE stream (`data: {...}\n\n`)
4. Backend maintains sessions in `_sessions: dict[str, XeusPythonExecutor]`
5. Executor yields results synchronously via generator

### Limitations
- **Unidirectional**: Can't cancel/interrupt from frontend
- **No state queries**: Can't ask "what's executing now?"
- **Connection fragility**: If SSE drops, execution state is lost
- **No progress tracking**: Just streaming results as they arrive

## Proposed Architecture (WebSocket)

### 1. Connection Model

**Single persistent WebSocket per browser tab**

```
Browser Tab → WebSocket → Backend Session
     ↓            ↓              ↓
  sessionId   bidirectional   XeusPythonExecutor
                               + ExecutionState
```

**Benefits:**
- Bidirectional communication (cancel, pause, query state)
- Persistent connection for multiple executions
- Clear connection lifecycle
- Can push updates proactively (variable changes, memory usage, etc.)

**Tradeoffs:**
- Need reconnection logic
- Connection state management
- Slightly more complex than SSE

### 2. Backend State Model

**Current:**
```python
_sessions: dict[str, XeusPythonExecutor]
```

**Proposed:**
```python
@dataclass
class ExecutionState:
    """State for a single execution (one execute-script call)"""
    execution_id: str                           # Unique per execution
    session_id: str                             # Which session owns this
    script: str                                 # Full script being executed
    line_range: tuple[int, int] | None         # Partial execution range

    # Expression tracking
    expressions: list[ExpressionInfo]          # All expressions in this run
    results: dict[int, ExecutionResult]        # node_index → result

    # Progress tracking
    status: Literal['pending', 'running', 'completed', 'cancelled', 'error']
    current_index: int | None                  # Currently executing expression
    error_message: str | None

    # Timing
    started_at: datetime
    completed_at: datetime | None

    # Execution control
    task: asyncio.Task | None                  # Background task (for cancellation)

@dataclass
class Session:
    """A session represents a persistent Python kernel + connection"""
    session_id: str
    executor: XeusPythonExecutor               # Python kernel wrapper
    websocket: WebSocket | None                # Current active connection
    current_execution: ExecutionState | None   # Currently running execution
    execution_history: dict[str, ExecutionState]  # Recent executions (for reconnection)
    created_at: datetime
    last_active: datetime

# Global registry
_sessions: dict[str, Session] = {}
```

**Why this design:**
- **Separation of concerns**: Session (kernel + connection) vs Execution (one run)
- **Cancellation**: `task` reference allows `task.cancel()`
- **Reconnection**: `execution_history` allows resuming/querying after disconnect
- **Progress tracking**: `current_index` + `status` enable real-time progress
- **Multiple executions**: Can track history, though only one active at a time per session

### 3. Message Protocol

#### Client → Server

```typescript
// 1. Initialize connection (first message after WS opens)
interface InitMessage {
  type: 'init'
  sessionId: string  // From crypto.randomUUID() in frontend
}

// 2. Execute script
interface ExecuteMessage {
  type: 'execute'
  executionId: string     // Generated by frontend (crypto.randomUUID())
  script: string
  scriptName: string
  lineRange?: { from: number; to: number }
  reset?: boolean         // Reset namespace before executing
}

// 3. Cancel running execution
interface CancelMessage {
  type: 'cancel'
  executionId: string
}

// 4. Query execution state (for reconnection or debugging)
interface GetStateMessage {
  type: 'get-state'
  executionId: string
}

// 5. Reset namespace
interface ResetMessage {
  type: 'reset'
}

// 6. Heartbeat (keep connection alive)
interface PingMessage {
  type: 'ping'
}

type ClientMessage =
  | InitMessage
  | ExecuteMessage
  | CancelMessage
  | GetStateMessage
  | ResetMessage
  | PingMessage
```

#### Server → Client

```typescript
// 1. Acknowledge initialization
interface InitAckMessage {
  type: 'init-ack'
  sessionId: string
}

// 2. Execution started (includes expression list)
interface ExecutionStartedMessage {
  type: 'execution-started'
  executionId: string
  expressions: Array<{
    nodeIndex: number
    lineStart: number
    lineEnd: number
  }>
}

// 3. Expression execution started
interface ExpressionStartedMessage {
  type: 'expression-started'
  executionId: string
  nodeIndex: number
  lineStart: number
  lineEnd: number
}

// 4. Expression execution completed
interface ExpressionDoneMessage {
  type: 'expression-done'
  executionId: string
  nodeIndex: number
  lineStart: number
  lineEnd: number
  output: OutputItem[]
  isInvisible: boolean
}

// 5. Execution completed successfully
interface ExecutionCompleteMessage {
  type: 'execution-complete'
  executionId: string
}

// 6. Execution cancelled
interface ExecutionCancelledMessage {
  type: 'execution-cancelled'
  executionId: string
  reason?: string
}

// 7. Execution error
interface ExecutionErrorMessage {
  type: 'execution-error'
  executionId: string
  error: string
  nodeIndex?: number  // Which expression failed (if known)
}

// 8. Full state response (for get-state query)
interface StateMessage {
  type: 'state'
  executionId: string
  state: {
    status: 'pending' | 'running' | 'completed' | 'cancelled' | 'error'
    currentIndex: number | null
    expressions: ExpressionInfo[]
    results: Record<number, ExecutionResult>
    errorMessage: string | null
  }
}

// 9. Heartbeat response
interface PongMessage {
  type: 'pong'
}

// 10. General error (connection-level, not execution-specific)
interface ErrorMessage {
  type: 'error'
  error: string
}

type ServerMessage =
  | InitAckMessage
  | ExecutionStartedMessage
  | ExpressionStartedMessage
  | ExpressionDoneMessage
  | ExecutionCompleteMessage
  | ExecutionCancelledMessage
  | ExecutionErrorMessage
  | StateMessage
  | PongMessage
  | ErrorMessage
```

### 4. Async Implementation

#### Backend Changes

**Current (sync generator):**
```python
def execute_script(self, script: str, ...) -> Generator[...]:
    statements = self._parse_script(script)
    yield [ExpressionInfo(...) for stmt in statements]

    for stmt in statements:
        output = self._execute_code(stmt.source)
        yield ExecutionResult(...)
```

**Proposed (async):**
```python
async def execute_script(
    self,
    script: str,
    websocket: WebSocket,
    execution_state: ExecutionState,
    ...
) -> None:
    """Execute script and send results via WebSocket"""

    # 1. Parse script
    statements = self._parse_script(script)
    expressions = [ExpressionInfo(...) for stmt in statements]
    execution_state.expressions = expressions

    # 2. Send execution started
    await websocket.send_json({
        'type': 'execution-started',
        'executionId': execution_state.execution_id,
        'expressions': [expr.model_dump() for expr in expressions]
    })

    # 3. Execute each statement
    for i, stmt in enumerate(statements):
        # Check if cancelled
        if execution_state.status == 'cancelled':
            break

        # Update state
        execution_state.current_index = i

        # Send expression started
        await websocket.send_json({
            'type': 'expression-started',
            'executionId': execution_state.execution_id,
            'nodeIndex': stmt.node_index,
            'lineStart': stmt.line_start,
            'lineEnd': stmt.line_end,
        })

        # Execute (run in thread pool since kernel is sync)
        output = await asyncio.to_thread(
            self._execute_code,
            stmt.source
        )

        # Create result
        result = ExecutionResult(
            node_index=stmt.node_index,
            line_start=stmt.line_start,
            line_end=stmt.line_end,
            output=output,
            is_invisible=len(output) == 0
        )
        execution_state.results[stmt.node_index] = result

        # Send result
        await websocket.send_json({
            'type': 'expression-done',
            'executionId': execution_state.execution_id,
            **result.model_dump()
        })

    # 4. Mark complete
    if execution_state.status == 'cancelled':
        await websocket.send_json({
            'type': 'execution-cancelled',
            'executionId': execution_state.execution_id
        })
    else:
        execution_state.status = 'completed'
        execution_state.completed_at = datetime.now()
        await websocket.send_json({
            'type': 'execution-complete',
            'executionId': execution_state.execution_id
        })
```

**WebSocket Handler:**
```python
@app.websocket("/ws/execute")
async def execute_websocket(websocket: WebSocket):
    await websocket.accept()
    session: Session | None = None

    try:
        # 1. First message must be 'init'
        init_msg = await websocket.receive_json()
        if init_msg['type'] != 'init':
            await websocket.send_json({
                'type': 'error',
                'error': 'First message must be init'
            })
            return

        # 2. Get or create session
        session_id = init_msg['sessionId']
        session = get_or_create_session(session_id)
        session.websocket = websocket
        session.last_active = datetime.now()

        # 3. Acknowledge
        await websocket.send_json({
            'type': 'init-ack',
            'sessionId': session_id
        })

        # 4. Message loop
        while True:
            msg = await websocket.receive_json()

            if msg['type'] == 'execute':
                await handle_execute(session, msg, websocket)

            elif msg['type'] == 'cancel':
                await handle_cancel(session, msg, websocket)

            elif msg['type'] == 'get-state':
                await handle_get_state(session, msg, websocket)

            elif msg['type'] == 'reset':
                session.executor.reset()

            elif msg['type'] == 'ping':
                await websocket.send_json({'type': 'pong'})

    except WebSocketDisconnect:
        # Clean up connection reference but keep session alive
        if session:
            session.websocket = None

    except Exception as e:
        await websocket.send_json({
            'type': 'error',
            'error': str(e)
        })

async def handle_execute(session: Session, msg: dict, websocket: WebSocket):
    """Handle execute message"""

    # 1. Check if already executing
    if session.current_execution and session.current_execution.status == 'running':
        await websocket.send_json({
            'type': 'error',
            'error': 'Execution already in progress'
        })
        return

    # 2. Create execution state
    execution_state = ExecutionState(
        execution_id=msg['executionId'],
        session_id=session.session_id,
        script=msg['script'],
        line_range=msg.get('lineRange'),
        status='pending',
        started_at=datetime.now(),
        expressions=[],
        results={},
        current_index=None,
        error_message=None,
        task=None
    )
    session.current_execution = execution_state
    session.execution_history[execution_state.execution_id] = execution_state

    # 3. Reset if requested
    if msg.get('reset'):
        session.executor.reset()

    # 4. Start execution in background
    execution_state.status = 'running'
    task = asyncio.create_task(
        session.executor.execute_script(
            script=msg['script'],
            websocket=websocket,
            execution_state=execution_state,
            line_range=execution_state.line_range,
            script_name=msg.get('scriptName', '<script>')
        )
    )
    execution_state.task = task

    # 5. Wait for completion (but don't block message loop)
    # This is handled by the task itself

async def handle_cancel(session: Session, msg: dict, websocket: WebSocket):
    """Handle cancel message"""
    execution_id = msg['executionId']

    # Find execution
    execution = session.execution_history.get(execution_id)
    if not execution:
        await websocket.send_json({
            'type': 'error',
            'error': f'Execution {execution_id} not found'
        })
        return

    # Cancel if running
    if execution.status == 'running' and execution.task:
        execution.status = 'cancelled'
        execution.task.cancel()
        execution.completed_at = datetime.now()

        await websocket.send_json({
            'type': 'execution-cancelled',
            'executionId': execution_id
        })

async def handle_get_state(session: Session, msg: dict, websocket: WebSocket):
    """Handle get-state message (for reconnection)"""
    execution_id = msg['executionId']

    execution = session.execution_history.get(execution_id)
    if not execution:
        await websocket.send_json({
            'type': 'error',
            'error': f'Execution {execution_id} not found'
        })
        return

    await websocket.send_json({
        'type': 'state',
        'executionId': execution_id,
        'state': {
            'status': execution.status,
            'currentIndex': execution.current_index,
            'expressions': [expr.model_dump() for expr in execution.expressions],
            'results': {
                idx: result.model_dump()
                for idx, result in execution.results.items()
            },
            'errorMessage': execution.error_message
        }
    })
```

#### Frontend Changes

**Current (SSE client):**
```typescript
async *executeScript(script: string, options): AsyncGenerator<ExecutionEvent> {
  const response = await fetch('/api/execute-script', {...});
  const reader = response.body.getReader();

  // Parse SSE manually
  while (true) {
    const { done, value } = await reader.read();
    // ... parse and yield events
  }
}
```

**Proposed (WebSocket client):**
```typescript
class ExecutionWebSocket {
  private ws: WebSocket | null = null;
  private sessionId: string;
  private messageHandlers = new Map<string, (msg: ServerMessage) => void>();
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 5;

  constructor(sessionId: string) {
    this.sessionId = sessionId;
  }

  async connect(): Promise<void> {
    return new Promise((resolve, reject) => {
      this.ws = new WebSocket(`ws://${location.host}/ws/execute`);

      this.ws.onopen = async () => {
        // Send init message
        this.send({ type: 'init', sessionId: this.sessionId });

        // Wait for init-ack
        const ackHandler = (msg: ServerMessage) => {
          if (msg.type === 'init-ack') {
            this.messageHandlers.delete('init-ack');
            this.reconnectAttempts = 0;
            resolve();
          }
        };
        this.messageHandlers.set('init-ack', ackHandler);
      };

      this.ws.onmessage = (event) => {
        const msg = JSON.parse(event.data) as ServerMessage;

        // Route to handlers
        const handler = this.messageHandlers.get(msg.type);
        if (handler) {
          handler(msg);
        }
      };

      this.ws.onclose = () => {
        this.handleDisconnect();
      };

      this.ws.onerror = (error) => {
        reject(error);
      };
    });
  }

  private async handleDisconnect() {
    // Exponential backoff reconnection
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      const delay = Math.min(1000 * 2 ** this.reconnectAttempts, 30000);
      this.reconnectAttempts++;

      await new Promise(resolve => setTimeout(resolve, delay));
      await this.connect();
    }
  }

  send(msg: ClientMessage) {
    if (this.ws?.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify(msg));
    }
  }

  on(type: string, handler: (msg: ServerMessage) => void) {
    this.messageHandlers.set(type, handler);
  }

  off(type: string) {
    this.messageHandlers.delete(type);
  }

  async *executeScript(script: string, options): AsyncGenerator<ExecutionEvent> {
    const executionId = crypto.randomUUID();
    const events: ExecutionEvent[] = [];
    let done = false;
    let error: Error | null = null;

    // Set up handlers
    this.on('execution-started', (msg) => {
      events.push({ type: 'expressions', expressions: msg.expressions });
    });

    this.on('expression-done', (msg) => {
      events.push({
        type: 'done',
        expression: {
          lineStart: msg.lineStart,
          lineEnd: msg.lineEnd,
          output: msg.output,
          isInvisible: msg.isInvisible
        }
      });
    });

    this.on('execution-complete', () => {
      done = true;
    });

    this.on('execution-error', (msg) => {
      error = new Error(msg.error);
      done = true;
    });

    // Send execute message
    this.send({
      type: 'execute',
      executionId,
      script,
      scriptName: options.scriptName,
      lineRange: options.lineRange,
      reset: options.reset
    });

    // Yield events as they arrive
    while (!done) {
      if (events.length > 0) {
        yield events.shift()!;
      } else {
        await new Promise(resolve => setTimeout(resolve, 10));
      }
    }

    // Yield remaining events
    while (events.length > 0) {
      yield events.shift()!;
    }

    if (error) {
      throw error;
    }

    // Clean up handlers
    this.off('execution-started');
    this.off('expression-done');
    this.off('execution-complete');
    this.off('execution-error');
  }

  cancelExecution(executionId: string) {
    this.send({ type: 'cancel', executionId });
  }

  async getExecutionState(executionId: string): Promise<ExecutionState> {
    return new Promise((resolve) => {
      const handler = (msg: StateMessage) => {
        this.off('state');
        resolve(msg.state);
      };
      this.on('state', handler);
      this.send({ type: 'get-state', executionId });
    });
  }
}
```

### 5. Reconnection Strategy

**Scenario: WebSocket drops mid-execution**

1. **Frontend detects disconnect** (`ws.onclose`)
2. **Automatic reconnection** with exponential backoff:
   - Attempt 1: 1s delay
   - Attempt 2: 2s delay
   - Attempt 3: 4s delay
   - Attempt 4: 8s delay
   - Attempt 5: 16s delay
   - Give up after 5 attempts
3. **On reconnect:**
   - Send `init` with same sessionId
   - Send `get-state` with last executionId
   - Backend returns current state
4. **Frontend reconciles:**
   - If execution still running: wait for more results
   - If execution completed: apply cached results
   - If execution cancelled/error: show final state

**Backend state retention:**
- Keep `execution_history` for 5 minutes after completion
- Clean up old executions periodically
- If client reconnects after cleanup, return error (client should refresh)

### 6. Implementation Phases

#### Phase 1: Backend WebSocket Infrastructure
**Files to modify:**
- `pdit/server.py`: Add `/ws/execute` endpoint
- `pdit/executor.py`: Add `ExecutionState` and `Session` models
- `pdit/xeus_executor.py`: Keep sync for now, will async in Phase 2

**Tasks:**
1. Define Pydantic models for ExecutionState, Session
2. Implement WebSocket handler with message routing
3. Implement handle_execute, handle_cancel, handle_get_state
4. Wrap sync executor in asyncio.to_thread()
5. Add session cleanup (remove old executions after 5min)

**Testing:**
- Manual WebSocket client (websocat or browser console)
- Test execute flow
- Test cancellation
- Test reconnection with get-state

#### Phase 2: Async Executor
**Files to modify:**
- `pdit/xeus_executor.py`: Convert to async

**Tasks:**
1. Make `execute_script()` async
2. Use `asyncio.to_thread()` for blocking kernel operations
3. Check cancellation between expressions
4. Add proper error handling

**Testing:**
- Same as Phase 1 but with native async

#### Phase 3: Frontend WebSocket Client
**Files to modify:**
- `web/src/execution-backend-python.ts`: Replace SSE with WebSocket
- `web/src/Script.tsx`: Update to use new client

**Tasks:**
1. Implement `ExecutionWebSocket` class
2. Implement reconnection logic
3. Update `executeScript()` to use WebSocket
4. Keep same AsyncGenerator interface for compatibility

**Testing:**
- Full integration testing
- Test reconnection by killing backend mid-execution
- Test multiple executions
- Test cancellation from UI

#### Phase 4: Enhanced Features
**New features enabled by WebSocket:**
1. **Cancellation UI**: Add "Stop" button
2. **Progress indicator**: Show "Executing line 5/10"
3. **State persistence**: Store execution history in localStorage
4. **Variable inspector**: Push variable changes proactively
5. **Kernel restart**: Add "Restart Kernel" button

### 7. Migration Strategy

**Compatibility:**
- Run WebSocket and SSE endpoints in parallel initially
- Feature flag to switch between SSE and WebSocket
- Gradual rollout

**Rollback plan:**
- Keep SSE code for 1 release
- If WebSocket has issues, flip feature flag back to SSE

### 8. Open Questions

1. **Should we allow multiple concurrent executions per session?**
   - Current design: One execution at a time
   - Alternative: Queue executions or allow parallel
   - Recommendation: One at a time (simpler, matches Jupyter behavior)

2. **How long to keep execution history?**
   - Current design: 5 minutes
   - Alternative: Until session ends, configurable TTL
   - Recommendation: 5 minutes (balances memory vs reconnection)

3. **Should we support resuming partial executions after reconnect?**
   - Current design: If reconnect mid-execution, continue from current expression
   - Alternative: Restart from beginning
   - Recommendation: Continue (better UX, shows we have proper state)

4. **Heartbeat interval?**
   - WebSocket can drop silently
   - Recommendation: 30s ping/pong to detect dead connections

5. **Error handling for kernel crashes?**
   - If xeus kernel crashes, should we auto-restart?
   - Recommendation: Send error to client, let user decide to restart

## Summary

This design provides:
- ✅ **Bidirectional communication** for cancellation and queries
- ✅ **Proper state management** with ExecutionState tracking
- ✅ **Async architecture** for better performance
- ✅ **Reconnection support** for reliability
- ✅ **Backwards compatibility** via same AsyncGenerator interface
- ✅ **Future extensibility** for features like variable inspection, debugging

The migration is substantial but structured into clear phases with testing points.
